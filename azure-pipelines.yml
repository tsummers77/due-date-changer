# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

pool:
  name: PennState-dotnet-linux-agent
  vmImage: 'ubuntu-latest'

#Your build pipeline references the ‘ddc.docker.tag’ variable, which you’ve selected to be settable at queue time. Create or edit the build pipeline for this YAML file, define the variable on the Variables tab, and then select the option to make it settable at queue time. See https://go.microsoft.com/fwlink/?linkid=865971

steps:
- script: |
    from collections import defaultdict
    import sys
    from datetime import datetime
    import json
    import logging
    from logging.handlers import RotatingFileHandler
    import re
    
    import requests
    
    from flask import Flask, redirect, render_template, request, url_for, Response
    from canvasapi import Canvas
    from canvasapi.user import User
    from canvasapi.exceptions import CanvasException
    from pylti.flask import lti
    from pytz import utc, timezone
    
    import config
    
    
    app = Flask(__name__)
    app.config.from_object('config')
    
    if __name__ != "__main__":
        gunicorn_logger = logging.getLogger("gunicorn.error")
        app.logger.handlers = gunicorn_logger.handlers
        app.logger.setLevel(gunicorn_logger.level)
    if __name__ == "__main__":
        app.run(host="0.0.0.0", port=8080, debug=True)
    handler = logging.StreamHandler(sys.stdout)
    app.logger.addHandler(handler)
    
    canvas = Canvas(config.CANVAS_URL, config.API_KEY)
    
    
    def error(exception=None):
        return Response(
            render_template(
                'error.htm.j2',
                message=exception.get(
                    'exception',
                    'Please contact your System Administrator.'
                )
            )
        )
    
    
    @app.route('/launch', methods=['GET', 'POST'])
    @lti(error=error, request='initial', role='staff', app=app)
    def launch(lti=lti):
        canvas_domain = request.values.get('custom_canvas_api_domain')
        if canvas_domain not in config.ALLOWED_CANVAS_DOMAINS:
            msg = (
                '<p>This tool is only available from the following domain(s):<br/>{}</p>'
                '<p>You attempted to access from this domain:<br/>{}</p>'
            )
            return render_template(
                'error.htm.j2',
                message=msg.format(', '.join(config.ALLOWED_CANVAS_DOMAINS), canvas_domain),
            )
    
        course_id = request.form.get('custom_canvas_course_id')
    
        return redirect(url_for('show_assignments', course_id=course_id))
    
    
    @app.route('/', methods=['GET'])
    def index(lti=lti):
        app.logger.info("entering index ho ho ho")
        return "Please contact your System Administrator."
    
    
    @app.route('/status', methods=['GET'])
    def status():
        """
        Runs smoke tests and reports status
        """
        status = {
            'tool': 'Due Date Changer',
            'checks': {
                'index': False,
                'xml': False,
                'api_key': False,
            },
            'url': url_for('index', _external=True),
            'xml_url': url_for('xml', _external=True),
            'canvas_url': config.CANVAS_URL,
            'debug': app.debug
        }
    
        # Check index
        try:
            response = requests.get(url_for('index', _external=True), verify=False)
            status['checks']['index'] = response.text == 'Please contact your System Administrator.'
        except Exception as e:
            app.logger.exception('Index check failed.')
    
        # Check xml
        try:
            response = requests.get(url_for('xml', _external=True), verify=False)
            status['checks']['xml'] = 'application/xml' in response.headers.get('Content-Type')
        except Exception as e:
            app.logger.exception('XML check failed.')
    
        # Check API Key
        try:
            self_user = canvas.get_user('self')
            status['checks']['api_key'] = isinstance(self_user, User)
        except Exception as e:
            app.logger.exception('API check failed.')
    
        # Overall health check - if all checks are True
        status['healthy'] = all(v is True for k, v in status['checks'].items())
    
        return Response(
            json.dumps(status),
            mimetype='application/json'
        )
    
    
    @app.route('/course/<course_id>/assignments', methods=['GET'])
    @lti(error=error, request='session', role='staff', app=app)
    def show_assignments(course_id, lti=lti):
        app.logger.info("entering show_assignments ho ho ho")
        try:
            course = canvas.get_course(course_id)
            assignments = course.get_assignments()
            quiz_dict = {quiz.id: quiz for quiz in course.get_quizzes()}
        except CanvasException as err:
            app.logger.exception(
                'Error getting course, assignments or quizzes from Canvas.'
            )
            return error({'exception': err})
    
        assignment_quiz_list = []
        try:
            for assignment in assignments:
                if hasattr(assignment, 'quiz_id'):
                    quiz = quiz_dict.get(assignment.quiz_id)
                    if hasattr(quiz, 'show_correct_answers_at_date'):
                        assignment.show_correct_answers_at_date = datetime_localize(
                            quiz.show_correct_answers_at_date
                        )
                    if hasattr(quiz, 'hide_correct_answers_at_date'):
                        assignment.hide_correct_answers_at_date = datetime_localize(
                            quiz.hide_correct_answers_at_date
                        )
                assignment_quiz_list.append(assignment)
        except CanvasException as err:
            app.logger.exception('Error getting assignments from Canvas.')
            return error({'exception': err})
    
        return render_template(
            'assignments.htm.j2',
            assignments=assignment_quiz_list,
            course=course
        )
    
    
    @app.route('/course/<course_id>/update', methods=['POST'])
    @lti(error=error, request='session', role='staff', app=app)
    def update_assignments(course_id, lti=lti):
    
        def fix_date(value):
            try:
                value = datetime.strptime(value, config.LOCAL_TIME_FORMAT)
                value = local_tz.localize(value)
                return value.isoformat()
            except (ValueError, TypeError):
                # Not a valid time. Just ignore.
                return ''
    
        def error_json(assignment_id, updated_list):
            msg = 'There was an error editing one of the assignments. (ID: {})'
            msg = msg.format(assignment_id)
            if len(updated_list) > 0:
                '{} {} assignments have been updated successfully.'.format(
                    msg,
                    len(updated_list)
                )
    
            return Response(
                json.dumps({
                    'error': True,
                    'message': msg,
                    'updated': updated_list,
                }),
                mimetype='application/json'
            )
    
        if not request.is_xhr:
            return render_template('error.htm.j2', message='Non-AJAX requests not allowed.')
    
        try:
            course = canvas.get_course(course_id)
        except CanvasException:
            msg = 'Error getting course #{}.'.format(course_id)
            app.logger.exception(msg)
            return Response(
                json.dumps({
                    'error': True,
                    'message': msg,
                    'updated': []
                }),
                mimetype='application/json'
            )
    
        post_data = request.form
    
        local_tz = timezone(config.TIME_ZONE)
        assignment_field_map = defaultdict(dict)
    
        for key, value in post_data.iteritems():
            if not re.match(r'\d+-[a-z_]+', key):
                continue
    
            assignment_id, field_name = key.split('-')
            assignment_field_map[assignment_id].update({field_name: value})
    
        if len(assignment_field_map) < 1:
            return Response(
                json.dumps({
                    'error': True,
                    'message': 'There were no assignments to update.',
                    'updated': []
                }),
                mimetype='application/json'
            )
    
        updated_list = []
        for assignment_id, field in assignment_field_map.iteritems():
            assignment_type = field.get('assignment_type', 'assignment')
            quiz_id = field.get('quiz_id')
    
            payload = {
                'published': field.get('published') == 'on',
                'due_at': fix_date(field.get('due_at')),
                'lock_at': fix_date(field.get('lock_at')),
                'unlock_at': fix_date(field.get('unlock_at')),
            }
    
            if assignment_type == 'quiz' and quiz_id:
                payload.update({
                    'show_correct_answers_at': fix_date(
                        field.get('show_correct_answers_at')
                    ),
                    'hide_correct_answers_at': fix_date(
                        field.get('hide_correct_answers_at')
                    )
                })
    
                try:
                    quiz = course.get_quiz(quiz_id)
                    quiz.edit(quiz=payload)
                    updated_list.append({
                        'id': assignment_id,
                        'title': quiz.title,
                        'type': 'Quiz'
                    })
                except CanvasException:
                    app.logger.exception('Error getting/editing quiz #{}.'.format(
                        quiz_id
                    ))
    
                    return error_json(assignment_id, updated_list)
    
            else:
                try:
                    assignment = course.get_assignment(assignment_id)
                    assignment.edit(assignment=payload)
                    updated_list.append({
                        'id': assignment_id,
                        'title': assignment.name,
                        'type': 'Assignment'
                    })
                except CanvasException:
                    app.logger.exception('Error getting/editing assignment #{}.'.format(
                        assignment_id
                    ))
    
                    return error_json(assignment_id, updated_list)
    
        return Response(
            json.dumps({
                'error': False,
                'message': 'Successfully updated {} assignments.'.format(len(updated_list)),
                'updated': updated_list,
            }),
            mimetype='application/json'
        )
    
    
    @app.route('/lti.xml', methods=['GET'])
    def xml():
        return Response(
            render_template('lti.xml.j2'),
            mimetype='application/xml'
        )
    
    
    @app.template_filter()
    def datetime_localize(utc_datetime, format=config.LOCAL_TIME_FORMAT):
        if not utc_datetime.tzinfo:
            # Localize to UTC if there is no timezone information.
            utc_datetime = utc.localize(utc_datetime)
    
        new_tz = timezone(config.TIME_ZONE)
        local_datetime = utc_datetime.astimezone(new_tz)
    
        return local_datetime.strftime(format)
    

  displayName: 'Send log messages to stdout'
  enabled: false

- script: |
   echo "# -*- coding: utf-8 -*-
   from __future__ import unicode_literals
   import os
   
   DEBUG = True 
   SECRET_KEY = os.urandom(24)
   
   ALLOWED_CANVAS_DOMAINS = [os.environ.get('CANVAS_URL').split('https://')[1]] 
   
   CANVAS_URL = os.environ.get('CANVAS_URL')
   API_KEY = os.environ.get('CANVAS_ACCESS_TOKEN') # Note that the variable name, API_KEY, is misleading. The expected value here is a Canvas access token. -- apn114, 9/16/2019
   
   PYLTI_CONFIG = { 
       'consumers': { 
           os.environ.get('CONSUMER_KEY'): { 
               'secret': os.environ.get('SHARED_SECRET').encode()
           } 
       }, 
       'roles': { 
           'staff': [ 
               'urn:lti:instrole:ims/lis/Administrator', 
               'Instructor', 
               'ContentDeveloper', 
               'urn:lti:role:ims/lis/TeachingAssistant' 
           ] 
       } 
   } 
   
   TIME_ZONE = 'US/Eastern' 
   LOCAL_TIME_FORMAT = '%m/%d/%Y %I:%M %p' 
   
   LOG_FILE = 'due_date_changer.log'
   LOG_FORMAT = '%(asctime)s [%(levelname)s] {%(filename)s:%(lineno)d} %(message)s' 
   LOG_LEVEL = 'DEBUG' 
   LOG_MAX_BYTES = 1024 * 1024 * 5  # 5 MB 
   LOG_BACKUP_COUNT = 1
   " > ./config.py
   
   cat ./config.py
  displayName: 'Generate application configuration file'

- script: |
   # Generate nginx_default.conf
   # Notes:
   # - proxy_pass directs all traffic to gunicorn
   echo "
   server {
       location /static { 
           alias /var/www/html/static/; 
       } 
   
       location / { 
           proxy_pass http://0.0.0.0:8080;
           proxy_redirect               off; 
           proxy_set_header             Host \$host; 
           proxy_set_header             X-Real-IP \$remote_addr; 
           proxy_set_header             X-Forwarded-For \$proxy_add_x_forwarded_for; 
       }
   }
   " > ./nginx_default.conf
  displayName: 'Generate Nginx configuration file'

- script: |
   # Generate app.start
   # Note on the application workflow:
   # - Due Date Changer is designed to be run in Python Flask
   # - Gunicorn is used to serve the Flask application
   # - Nginx will proxy all requests to Gunicorn
   echo '#!/bin/sh
   gunicorn -b 0.0.0.0:8080 lti:app --daemon
   nginx -g "daemon off;"
   ' > ./app.start
  displayName: 'Generate application start file'

- task: Docker@2
  displayName: 'Build Docker container'
  inputs:
    containerRegistry: Nexus
    repository: '$(ddc.docker.imageName)'
    Dockerfile: 'nginx-flask.Dockerfile'
    buildContext: '$(build.sourcesDirectory)'
    tags: '$(ddc.docker.tag)'

- script: |
   echo ==============================================================================
   echo Clean-up Docker image
   echo Remove $(ddc.docker.imageName) and nginx:stable-alpine
   echo ==============================================================================
   docker rmi $(ddc.docker.repositoryUrl)/$(ddc.docker.imageName):$(ddc.docker.tag)
   docker rmi $(ddc.docker.repositoryUrl)/$(ddc.docker.imageName):latest
   docker rmi $(ddc.docker.repositoryUrl)/$(ddc.docker.imageName)
   docker rmi nginx:stable-alpine
   
   echo ==============================================================================
   echo Let\'s verify that Due Date Changer is no longer in the Docker registry
   echo ==============================================================================
   echo List available docker containers
   echo ==============================================================================
   docker container ls -a
   
   echo ==============================================================================
   echo List available docker images
   echo ==============================================================================
   docker images 
   
  displayName: 'Clean-up Docker image'


trigger:
- master


